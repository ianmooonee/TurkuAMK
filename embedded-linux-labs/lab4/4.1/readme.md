## 4.1 Linux kernel timers

Cron mechanism provides high configurability, but is limited one minute resolution. Linux kernel timers can be applied from C code with sub-millisecond accuracy (some jitter is generated by OS processes taking CPU time). This folder contains provides an example of using the timers. Three timers are set up, and each timer event will trigger execution of handler code. You will want to build, debug and study the example.

1. When building the code, you need to have the vscode project setup similar to lab3. Take a copy of lab3/copy-stuff.sh to this folder, and edit it to copy the .vscode contents only. This project contains valid version of project configuration CMakeLists.txt, you dont want to overwrite it. Perform the copy. Test build: rebuild ctrl-shift-P "CMake: Delete cache and reconfigure" makes sure you have a clean build, then F7 to to build.

2. When debugging the code (F5), every timer trigger will stop the debugging session. You will want to choose your own breakpoints, so you need to tell gdb debugger via vscode setup to ignore timer exceptions. Edit the .vscode/launch.json part "setup commands" to include snippet
```
                {
                    "text": "handle SIG34 nostop noprint pass",
                    "description": "Allow debugger to run when timer events occur",
                    "ignoreFailures": false
                    },
```
and rebuild (ctrl-shift-P rebuild (ctrl-shift-P "CMake: Delete cache and reconfigure", then F5 to to build and debug).

### Exercise 4.1: kernel timers

Modify kernel timer example to produce software generated PWM pulses for a servo motor. Servo pulses shall occur every 20 milliseconds and the nominal pulse length for servo middle position is 1.5ms. The angular position is controlled with pulse modulation, where pulse width can vary from 1.0 ms to 2.0 ms. Linux kernel does not prefer using floats, and also in this case all parameters are integers. Clearly if we want to generate accurate output pulse widths, then having only integer values either 1 or 2 milliseconds is not good.  
- Modify the timer function to use interfaces with microseconds instead of milliseconds. Check all places where changed variables are used in calculations, and correct those calculations accordingly.
- Step 1: Create one timer task that activates every 20 milliseconds (PWM pulse start event). Bring in necessary header files and add GPIO output pin, and for testing, make it toggle every time event handler is called. Check with oscilloscope that output meets your expectations.
- Step 2: In that same pulse start event handler, create a new timer for PWM pulse length, initially of 1500 microseconds. The idea is to reset the GPIO pin in this 1500us timer handler, and have the GPIO pin always set in the 20msec timer. So, create a timer handler for this pulse stop timer. In pulse stop timer handler, turn off the output (and in pulse start event replace the toggle with plain output activation to high state). Debug and verify with oscilloscope. Measure jitter.
- Step 3: Get a real servo (choose a standard servo, as there are continuous-running servos as well) and connect it to raspi. Red wire to +5V, Black wire to GND, and white wire to your GPIO control pin. Test.
- Step 4: Commit updated code to your repository.
